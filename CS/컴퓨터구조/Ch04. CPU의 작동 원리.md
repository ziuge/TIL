# Chap4. CPU의 작동 원리

## 4-1. ALU와 제어장치

### ALU

**ALU가 받아들이는 정보**

- ALU는 계산하는 부품 → 계산하기 위해 피연산자와 연산이 필요함
- 레지스터를 통해 피연산자를, 제어장치로부터 (수행할 연산을 알려주는) 제어 신호를 받아들임

**ALU가 내보내는 정보**

- 결괏값은 일시적으로 레지스터에 저장됨
    - CPU가 메모리에 접근하는 속도 >>> 레지스터에 접근하는 속도 이므로
    - 프로그램 실행 속도를 높이기 위해서
- 플래그는 플래그 레지스터에 저장됨
    - 플래그: 연산 결과에 대한 추가적인 정보
        

- 이 밖에도 ALU 내부에 존재하는 회로들
    - 가산기(+), 보수기(-), 시프터, 오버플로우 검출기 등

### 제어장치

- 제어장치: 제어 신호를 내보내고 명령어를 해석하는 부품
- 제어 신호: 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호

**제어장치가 받아들이는 정보**

1. 클럭 신호
    - 클럭: 컴퓨터의 모든 부품을 움직이게 하는 시간 단위
    - 컴퓨터 부품들은 클럭이라는 박자에 맞춰 작동함 (한 박자마다 작동하는 건 아님)
2. 해석해야 할 명령어
    - from. 명령어 레지스터
3. 플래그 레지스터 속 플래그 값
    - 플래그 값을 참고하여 제어 신호를 발생시킴
4. 제어 버스로 전달된 제어 신호

**제어장치가 내보내는 정보**

- CPU 외부에 전달하는 제어 신호 - 제어 버스로 제어 신호를 내보냄
    - 메모리에 전달하는 제어 신호
        - 메모리에 저장된 값을 읽거나 메모리에 새로운 값을 쓰고 싶을 때
    - 입출력장치에 전달하는 제어 신호
        - 입출력장치의 값을 읽거나 입출력장치에 새로운 값을 쓰고 싶을 때
- CPU 내부에 전달하는 제어 신호
    - ALU에 전달하는 제어 신호
        - 수행할 연산 지시
    - 레지스터에 전달하는 제어 신호
        - 레지스터 간에 데이터 이동
        - 레지스터에 저장된 명령어 해석

## 4-2. 레지스터

명령어와 데이터는 실행 전후로 반드시 레지스터에 저장됨 → 레지스터를 관찰하면 프로그램의 실행 흐름을 파악할 수 있음

### 반드시 알아야 할 레지스터

1. 프로그램 카운터
    - 메모리에서 읽어 들일 명령어의 주소 저장
2. 명령어 레지스터
    - 방금 메모리에서 읽어 들인 명령어 저장
3. 메모리 주소 레지스터
    - 메모리의 주소 저장
4. 메모리 버퍼 레지스터 (메모리 데이터 레지스터)
    - 메모리와 주고받을 값 저장
5. 플래그 레지스터
    - 연산 결과 또는 CPU 상태에 대한 부가적인 정보 저장
6. 범용 레지스터
    - 다양하고 일반적인 상황에서 자유롭게 사용
7. 스택 포인터
8. 베이스 레지스터

### 특정 레지스터를 이용한 주소 지정 방식(1): 스택 주소 지정 방식

- 스택과 스택 포인터를 이용한 주소 지정 방식
- 스택 포인터: 스택의 꼭대기(스택에 마지막으로 저장한 값의 위치)를 가리키는 레지스터
- 메모리 안에 스택 영역이 존재함

### 특정 레지스터를 이용한 주소 지정 방식(2): 변위 주소 지정 방식

- 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더해 유효 주소를 얻어내는 주소 지정 방식
- 이 방식을 사용하는 명령어는 [연산 코드, 더할 레지스터의 값, 주소를 담는 오퍼랜드 필드]

**상대 주소 지정 방식**

- 오퍼랜드와 프로그램 카운터(읽어 들일 명령어의 주소)의 값을 더하여 유효 주소를 얻는 방식
- 분기하여 특정 주소의 코드를 실행할 때 사용

**베이스 레지스터 주소 지정 방식**

- 오퍼랜드(기준 주소로부터의 거리)와 베이스 레지스터(기준 주소)의 값을 더해 유효 주소를 얻는 방식

## 4-3. 명령어 사이클과 인터럽트

### 명령어 사이클

- 하나의 명령어를 처리하는 정형화된 흐름, 프로그램이 실행되며 반복되는 일정한 주기
1. 인출 사이클 fetch cycle: 메모리에 있는 명령어를 CPU로 가져오는 단계
2. 실행 사이클 execution cycle: 제어장치가 명령어 레지스터에 담긴 값을 해석하고, 제어 신호를 발생시키는 단계
3. 간접 사이클 indirect cycle: 메모리 접근을 한 번 더 하는 단계
    - 명령어를 인출한 뒤에 바로 실행 사이클에 돌입할 수 없는 경우
    ex. 간접 주소 지정 방식

### 인터럽트

- 명령어를 처리하다 흐름이 끊어지는 상황, CPU의 작업을 방해하는 신호

**동기 인터럽트**

- CPU에 의해 발생하는 인터럽트
- 예외적인 상황에 마주쳤을 때 발생 ⇒ **예외**

**비동기 인터럽트**

- 주로 입출력장치에 의해 발생하는 인터럽트
- ex. 프린터가 프린트를 끝낸 뒤에 CPU에 완료 알림(인터럽트)을 보냄, 
키보드, 마우스가 입력을 처리하기 위해 CPU에 입력 알림(인터럽트)를 보냄
- ⇒ **하드웨어 인터럽트**
    - 명령어를 효율적으로 처리하기 위해 사용됨
    - 순서:
        1. 입출력 장치는 CPU에 인터럽트 요청 신호를 보냄 
            - 인터럽트 요청 신호: 지금 끼어들어도 되나요?
        2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인함
        3. CPU는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인함 
            - 인터럽트 플래그: 인터럽트를 받아들일지 결정하는 플래그 in 플래그 레지스터
            - 인터럽트 플래그가 불가능이어도 무시할 수 없는 인터럽트 요청도 존재 - 정전, 하드웨어 고장 등
        4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업함
        5. CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행함
            - 인터럽트 서비스 루틴(인터럽트 핸들러): 인터럽트를 처리하기 위한 프로그램, 어떻게 행동해야 할지를 알려주는 프로그램
            - 인터럽트 백터: 인터럽트 서비스 루틴을 식별하기 위한 정보
        6. 인터럽트 서비스 루틴 실행이 끝나면 4에서 백업해 둔 작업을 복구하여 실행을 재개함
