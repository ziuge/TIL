# Chap5. CPU 성능 향상 기법

## 5-1. 빠른 CPU를 위한 설계 기법

### 클럭

- 클럭 신호가 빠르게 반복 → CPU 명령어 사이클도 빠르게 동작
- 클럭 속도 ⬆️ > CPU 성능 ⬆️
- 클럭 속도
    
    Hz(헤르츠)로, 1초에 n 번 반복하면 nHz
    (intel core은 기본 2.5GHz, 최대 속도 4.9GHz → 25억, 49억번)
    
    베이스 속도와 최대 클럭 속도 > 강제로 속도를 끌어올리는 **오버클럭킹 기법** 존재
    
    클럭 속도를 무작정 올리는 것이 CPU의 성능을 100% 개선한다고는 할 수 없음 (발열 문제)
    

### 코어와 멀티코어

- 전통적인 CPU는 컴퓨터에서 1개만 존재 > 기술의 발전으로 명령어를 실행하는 부품을 여러 개 넣을 수 있게 됨
    - '명령어를 실행하는 부품' > '명령어를 실행하는 부품을 여러 개 포함하는 부품' 로 CPU 개념이 바뀜

- 멀티코어 CPU (멀티코어 프로세서)는 단일 코어 CPU보다 성능이 좋음
- 코어의 개수에 따라 싱글/듀얼/트리플 코어라고 함
- **연산 속도는 코어 개수에 비례?** X,
중요한 것은 명령어의 적절한 분배

### 스레드와 멀티스레드

- 스레드: '실행 흐름의 단위'
- **하드웨어적 스레드**
    - '하나의 코어가 동시에 처리하는 명령어 단위'
    - 1코어 1스레드 CPU: 명령어를 실행하는 부품 1개에 한 번에 하나씩 명령어 실행
    - 멀티스레드 프로세서(CPU): 하나의 코어로 여러 명령어를 동시에 처리하는 CPU
  
    
- **소프트웨어적 스레드**
    - '하나의 프로그램에서 독립적으로 실행되는 단위'
    - UI 랜더링/저장 기능 등을 멀티 스레드에서 실행 가능
  
    
- **멀티스레드 프로세서**
    - 하나의 코어로 여러 개의 명령어를 동시에 실행할 수 있는 CPU
    - 하나의 코어에 레지스터를 하드웨어 스레드 개수만큼 추가
    - 한 번에 스레드 개수만큼 CPU 가 존재하는 것처럼 보이기 때문에 하드웨어 스레드를 **논리 프로세서**라고도 함

## 5-2 명령어 병렬 처리 기법

CPU를 놀게 하지 않고 작동시키는 기법

### 명령어 파이프라인

- 명령어 처리 과정
    1. 명령어 인출 (Instruction Fetch)
    2. 명령어 해석 (Instruction Decode)
    3. 명령어 실행 (Execute Instruction)
    4. 결과 저장 (Write Back)


- 위처럼 명령어의 단계가 겹치지 않는다면 CPU는 동시에 명령어 여러 개를 실행 시킬 수 있음
    - **명령어 파이프라이닝**: ****공장 생산 라인처럼 명령어 파이프라인에 넣고 동시에 처리하는 기법

**파이프라인 위험** (pipeline hazard): ****특정 상황에서 성능 향상에 실패하는 상황

- 데이터 위험: 데이터 의존성에 의해 발생
    
    ```c
    // 명령어 2는 명령어 1에 의존적임
    명령어 1: R1 <- R2 + R3 // R2 레지스터 값과 R3 레지스터 값을 더한 값을 R1 레지스터에 저장
    명령어 2: R4 <- R1 + R5 // R1 레지스터 값과 R5 레지스터 값을 더한 값을 R4 레지스터에 저장
    ```
    
- 제어 위험: 갑작스러운 프로그램 카운터의 변화에 의해 실행 중인 명령어들이 쓸모없어지는 상태
  
    
    - **분기 예측**으로 제어 위험을 예방 가능
- 구조적 위험: 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려고 할 때 발생 (= 자원 위험)

### 슈퍼스칼라

- 파이프라인의 개수를 여러 개 사용하는 구조
- 이러한 처리가 가능한 CPU를 **슈퍼스칼라 프로세서 (CPU)** 라고 함
- 멀티 스레드 프로세서에서 사용할 수 있고, 고도로 설계 되었을 경우 파이프라인 개수에 비례하여 처리 속도가 빨라짐

### 비순차적 명령어 처리

- 명령어들을 순차적으로 실행하지 않는, '합법적인 새치기'
- 순서 의존성이 없는 명령어를 먼저 실행하여 명령어 파이프라인이 멈추는 것을 방지하는 기법

```
1) M(100) <- 1
2) M(101) <- 2
3) M(102) <- M(100) + M(101) // 3번이 처리될 때까지 4-6이 기다릴 필요 X, 3을 맨 뒤로 이동
4) M(150) <- 1
5) M(151) <- 2
6) M(152) <- 3
```

## 5-3 CISC와 RISC

명령어가 어떻게 생겨야 명령어 파이프라이닝에 유리할까?

### 명령어 집합

- CPU 가 이해할 수 있는 명령어들의 모음 (명령어 집합 구조, ISA)
- CPU마다 ISA 는 다를 수 있음 (인텔과 애플 ISA 다름)
- ISA가 다르다면 똑같은 소스코드로 컴파일 했지만 다른 어셈블리어가 나올 수 있음
- ISA는 CPU의 언어이자 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속

### CISC

- Complex Instruction Set Computer, 복잡한 명령어 집합을 활용하는 컴퓨터
- 가변 길이 명령어를 활용하여 적은 수의 명령어로 프로그램을 실행할 수 있음
- 메모리 공간은 절약할 수 있으나, 명령어가 복잡하고 다양한 기능 제공으로 1)명령어의 크기와 2)실행 시간이 일정하지 않음 > 파이프라인 구현에 큰 걸림돌

- 또한 대다수의 복잡한 명령어는 사용 빈도가 낮음 > 쓰는 것만 쓰기 때문에 장점을 활용하기 어려워 성장의 한계 존재

### RISC

- CISC의 한계로 인해,
1. 명령어의 길이와 수행 시간이 짧고 규격화
2. 자주 쓰이는 기본적인 명령어를 작고 빠르게 만드는 것
    
    을 반영한 RISC(Reduced Instruction Set Computer) 등장
    
- 고정 길이 명령어를 활용하여 명령어 종류가 적고 짧고 규격화됨 (1클럭 내외)
- 메모리 접근을 단순화/최소화 함 (load, store로 제한) > 레지스터를 적극 활용
