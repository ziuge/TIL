# 1) 컴파일링

> 컴파일링의 네 단계를 설명할 수 있습니다.
> 
- 전처리
- 컴파일링
- 어셈블링
- 링킹

### 전처리 Precompile

- 전처리기로 수행됨
- #으로 시작되는 C 소스 코드는 전처리기에게 실질적인 컴파일이 이루어지기 전에 무언가를 실행하라고 알려줌
    - #include → 전처리기에게 다른 파일의 내용을 포함시키라고 알려줌
        
        stdio.h 파일의 내용이 이 부분에 포함됨
        

### 컴파일 Compile

- 컴파일러라고 불리는 프로그램은 C 코드를 어셈블리어라는 저수준 프로그래밍 언어로 컴파일함
- 어셈블리: C보다 연산의 종류는 적지만 여러 연산이 함께 사용되면 C에서 할 수 있는 모든 것을 수행 가능
- C코드를 어셈블리 코드로 변환 : 컴파일러는 컴퓨터가 이해할 수 있는 언어와 최대한 가까운 프로그램으로 만들어 줌

### 어셈블 Assemble

- 어셈블리 코드 → 오브젝트 코드 : 연속된 0과 1들로 바꿔줌

### 링크 Link

- 프로그램이 여러 개의 파일로 이루어져 있어 하나의 오브젝트 파일로 합쳐져야 한다면 이 단계가 필요함
- 여러 개의 다른 오브젝트 코드 파일을 실행 가능한 하나의 오브젝트 코드 파일로 합침.

<img width="534" alt="Untitled" src="https://github.com/ziuge/TIL/assets/79574342/e1fc929c-29e5-4a1d-8421-e24c457aba12">

# 2) 디버깅

> 디버깅 하는 여러 방법을 설명할 수 있습니다.
> 

### 버그와 디버깅

- 버그: 코드에 들어있는 오류
- 디버깅: 코드에 있는 버그를 식별하고 고치는 과정
- 디버거를 사용

### 디버깅의 기본

- 디버거 - 프로그램을 특정 행에서 멈출 수 있게 해주며 버그를 찾는데 도움을 줌
- 중지점: 프로그램이 멈추는 특정 지점

### help50

### printf

하나하나 프린트해서 확인

### debug50

# 3) 코드의 디자인

> 코드의 정확성과 디자인을 관리하는 방법을 설명할 수 있습니다.
> 

### check50

과제를 잘 수행했는지 검사

### style50

코드가 심미적으로 잘 작성되어 있는지 검사

- 공백의 수나 줄바꿈 - 사람에 따라 여러 방식으로 작성할 수 있음. 사내에서 작성할 때, 특정한 스타일 가이드를 따르도록 함

### 고무 오리

- 내가 작성한 코드를 한 줄 한 줄 말로 설명하는 과정

# 4) 배열(1)

### 메모리

- 자료형마다 다른 크기의 메모리를 차지함
    - bool: 불리언, 1바이트
    - char: 문자, 1바이트
    - int: 정수, 4바이트
    - float: 실수, 4바이트
    - long: (더 큰) 정수, 8바이트
    - double: (더 큰) 실수, 8바이트
    - string: 문자열, ?바이트
- 컴퓨터 안의 RAM이라는 물리적 칩이 메모리 역할을 함

### 배열

- 같은 자료형의 데이터를 메모리상에 연이어 저장하고 하나의 변수로 관리하기 위해 사용됨
    
    ```c
    // int
    int score1 = 72;
    int score2 = 73;
    int score3 = 33;
    
    // array
    int scores[3];
    scores[0] = 72;
    scores[1] = 73;
    scores[2] = 33;
    ```
    

# 5) 배열(2)

### 전역 변수

- 코드 전반에 거쳐 바뀌지 않는 값
- 고정된 값이 있는 변수라면, 그 값을 선언할 때 `const`를 앞에 붙여 전역 변수임을 표현
    
    ```c
    #include <cs50.h>
    #include <stdio.h>
    
    **const int N = 3;**
    
    int main(void) {
    	int scores[N];
    	scores[0] = 72;
    	scores[1] = 73;
    	scores[2] = 33;
    }
    ```
    

### 배열의 동적 선언 및 저장

- 사용자로부터 값을 입력받아 선언 및 저장

# 6) 문자열과 배열

- 문자열(string) 자료형의 데이터는 사실 문자(char) 자료형의 데이터들의 배열
    - `string s = “HI!”;`
        
        → `H`, `I`, `!`, `\0`
        
    - `\0`은 널 종단 문자 : 모든 비트가 0인 1바이트
- 문자열 안의 문자는 2차원 배열을 통해 접근 가능
    
    ```c
    string names[4];
    
    names[0] = "EMMA";
    names[1] = "RODRIGO";
    names[2] = "BRIAN";
    names[3] = "DAVID";
    
    // names[0][1] -> "M"
    ```
    

# 7) 문자열의 활용

### 문자열의 길이 및 탐색

- 문자열의 끝을 아는 방법?
    1. 널 종단 문자(\0)와 일치하는지 검사
        
        `for (int i = 0; s[i] != ‘\0’; i++)`
        
    2. `strlen()` : 문자열의 길이를 알려주는 함수
        
        `for (int i = 0, n = strlen(s); i < n; i++)`
        
        일일이 검사하는 것보다 효율적!
        

### 문자열 탐색 및 수정

- 문자열을 대문자로 바꿔주는 프로그램?
    1. ASCII 값을 32씩 뺀 후에 문자 형태로 출력
    2. `toupper()` 함수

# 8) 명령행 인자

- 명령행 인자: make나 clang과 같은 프로그램을 실행할 때 컴파일하고자 하는 코드 외에도 컴파일 후 저장하고자 하는 파일명과 같이 주는 추가적인 정보

```c
#include <cs50.h>
#include <stdio.h>

int main(int argc, string argv[])
{
    if (argc == 2)
    {
        printf("hello, %s\n", argv[1]);
    }
    else
    {
        printf("hello, world\n");
    }
}
```

- `argc`: main함수가 받게 될 입력의 개수
- `argv[]`: 그 입력이 포함되어 있는 배열
    - argv[0]: 프로그램의 이름으로 저장됨
    - argv[1]: 하나의 입력이 더 주어지면 여기에 저장됨

# Quiz

1. 컴파일링의 네 단계에 해당하지 않는 것은?
    1. 디버깅
2. 소스코드 내에 존재하는 오류를 해결하기 위한 작업은?
    1. 디버깅
3. 아래 코드를 어떻게 스타일 가이드에 부합한 코드로 만드는가?
    1. printf 함수를 들여쓰기해서 중괄호 {} 사이에 포함되었음을 표현한다.
4. char 자료형을 5개 담을 수 있는 [edwith]라는 이름의 배열을 선언하는 코드는?
    1. `char edwith[5];`
5. `int scores[10];`이라는 배열이 선언되어있을 때, 처음부터 끝까지 순환하는 for 루프는?
    1. `for (int i = 0; i < 10; i++) {… scores[i] …}`
6. string names[2];
names[0] = “MONSTER”;
names[1] = “MOM”;
아래에서 보기 중 값이 다른 것은?
    1. names[0][2]
7. 아래와 같은 main 함수를 지니는 edwith.c 코드소스를 작성하고 컴파일했습니다. ‘$ ./edwith hello world’를 실행하였을 때 argc의 값은?
int main(int argc, string argv[]) { }
    1. 3
8. C 소스파일의 링크, 컴파일, 빌드 작업을 자동화해주는 툴은?
    1. make
9. 소스코드를 작성할 때 우리가 의식적으로 또는 무의식적으로 저지른 실수나 오류를 통상적으로 일컫는 단어는?
    1. 버그 bug
10. 다음 중 문자열(string)이 메모리에 저장되는 방식에 대한 설명으로 틀린 것은?
    1. 문자열(string)은 포함된 문자(char) 개수 만큼의 메모리 자리를 차지한다
