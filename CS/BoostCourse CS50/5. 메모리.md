# 1) 메모리 주소

### 16진수 Hexadecimal

- 10진수보다 2진수를 간단하게 나타낼 수 있어 컴퓨터에서 데이터를 처리할 때 편함

### 10진수를 16진수로 바꾸어보기

- $2^4$ = 16 → 4bits씩 두 덩어리로 나누어 표현
- 16진수에서 10~15 → a~f를 대입하여 사용
- 4bits씩 16진수로 변환 후 0x를 뒤에 붙임

### 16진수의 유용성

- 10진수를 2진수로 표현… 길이가 너무 길어진다
- 16진수로 표현하면 2진수로 표현했을 때보다 훨씬 간단해짐
- 컴퓨터는 8개의 비트가 모인 바이트 단위로 정보를 표현함
- 2개의 16진수는 1byte의 2진수로 변환됨

### 메모리 주소

- C에서는 변수의 메모리상 주소를 받기 위해 “&” 연산자를 사용
    
    → 변수의 16진법으로 표현된 메모리 주소를 받을 수 있음
    
    ```c
    #include <stdio.h>int main(void)
    {
        int n = 50;
        printf("%p\n", &n);
    }
    // 0x7ffe00b3adbc
    ```
    
- “*”를 사용하면 그 메모리 주소에 있는 실제 값을 얻을 수 있음
    
    ```c
    #include <stdio.h>int main(void)
    {
        int n = 50;
        printf("%i\n", *&n);
    }
    // 50
    ```
    

# 2) 포인터

```c
#include <stdio.h>int main(void)
{
   int n = 50;
   int *p = &n; // *p 포인터 변수에 변수 n의 주소 저장
   printf("%p\n", p); // 변수 n의 주소를 출력
   printf("%i\n", *p); // p가 가리키는 변수의 값, 즉 변수 n의 값을 출력
}
```

- `int *p` : 변수 p가 포인터이고, 이 포인터가 int 타입의 변수를 가리킨다는 뜻

# 3) 문자열

```c
string s = “EMMA”; 
```

- 문자열은 문자의 배열. s[0], s[1], s[2]… \0(문자열의 끝)
- 변수 s는 결국 이 문자열을 가리키는 포인터가 됨. 더 정확하게는, 문자열의 가장 첫번째 문자인 s[0]을 가리키게 되는 것
- 실제로 CS50라이브러리에 정의된 string 자료형:
    
    ```c
    typedef char *string
    ```
    
    typedef새로운 자료형 char *문자에 대한 포인터 string자료형 이름
    
- 동일한 동작의 두 코드:
    1. string 자료형을 이용하여 “EMMA” 출력
        
        ```c
        #include <cs50.h>
        #include <stdio.h>
        
        int main(void)
        {
            string s = "EMMA";
            printf("%s\n", s);
        }
        ```
        
    2. char 포인터를 이용하여 “EMMA” 출력
        
        ```c
        #include <stdio.h>
        
        int main(void)
        {
            char *s = "EMMA"; // 변수 s는 문자에 대한 포인터, "EMMA" 문자열의 가장 첫번째 값을 저장
            printf("%s\n", s);
        }
        ```
        
# 4) 문자열 비교

```c
#include <stdio.h>int main(void)
{
    char *s = "EMMA";
    printf("%p\n", s);
}
```

위 코드를 실행하면, s라는 포인터의 값, 즉 “EMMA”라는 문자열의 가장 첫 값인 “E”에 해당하는 메모리 주소를 출력

```c
printf("%p\n", &s[0]); // 첫 번째 문자에 해당하는 주소값
printf("%p\n", &s[1]);
printf("%p\n", &s[2]);
printf("%p\n", &s[3]);
```

- 문자열은 첫 번째 문자를 시작으로 메모리상으로 바로 옆에 저장되어 있음
    - 가장 첫 번째 문자에 해당하는 주소값을 하나씩 증가시키면 바로 옆에 있는 문자의 값을 출력할 수 있음!

```c
printf("%c\n", *s); // E
printf("%c\n", *(s+1)); // M
printf("%c\n", *(s+2)); // M
printf("%c\n", *(s+3)); // A
```

문자열 비교를 위해서는 실제 문자열이 저장되어 있는 곳으로 이동하여, 각 문자를 하나하나 비교해야 함
