# 4. 알고리즘

# 1) 검색 알고리즘

- 배열: 한 자료형의 여러 값들이 메모리상에 모여 있는 구조
    - 접근할 때, 배열의 인덱스 하나하나에 접근
    - 어떤 값이 배열 안에 속해 있는지를 찾아보기 위해서는 배열의 정렬 여부에 따라 여러 방법을 사용할 수 있음

### 선형 검색

- 배열의 인덱스를 처음부터 끝까지 하나씩 증가시키면서 방문하여 그 값이 속하는지를 검사

### 이진 검색

- 정렬되어 있다면,
- 배열 중간 인덱스부터 시작하여 찾고자하는 값보다 작거나 큰 인덱스로 이동을 반복

# 2) 알고리즘 표기법

### Big O 표기법

- O: “on the order of”의 약자, 즉 “~만큼의 정도로 커지는”
- 알고리즘 실행 시간의 상한을 나타냄

> $O(n^2)$, $O(n log n)$, $O(n)$, $O(log n)$, $O(1)$
> 
- Big Ω: 실행 시간의 하한을 나타냄

# 3) 선형 검색

원하는 원소가 발견될 때까지 처음부터 마지막 자료까지 차례대로 검색

### 효율성 그리고 비효율성

- 선형 검색 알고리즘
    - 정확, 그러나 비효율적
    - 자료가 정렬되어 있지 않거나 그 어떤 정보도 없을 때 유용

# 4) 버블 정렬

📐O(n^2)

두 개의 인접한 자료 값을 비교하면서 위치를 교환하는 방식으로 정렬

- - : 단 하나의 요소를 정렬하기 위해 너무 많이 교환하는 낭비가 발생할 수도 있음

```
Repeat n–1 times

    For i from 0 to n–2

        If i'th and i+1'th elements out of order

            Swap them
```
# 5) 선택 정렬

📐 O(n^2)

- 배열 안의 자료 중 가장 작은 수(혹은 가장 큰 수)를 찾아 첫 번째 위치(혹은 마지막 위치)의 수와 교환해주는 방식으로 정렬
- 교환 횟수를 최소화, 비교하는 횟수는 증가

```
For i from 0 to n-1
	Find smallest item between i'th item and last item
	Swap smallest item with i'th item
```

# 6) 정렬 알고리즘의 실행시간

### 실행시간의 상한

- O(n^2): 선택 정렬, 버블 정렬
- O(n log n):
- O(n): 선형 검색
- O(logn): 이진 검색
- O(1)

### 실행시간의 하한

- Ω(n^2)$: 선택 정렬
- Ω(n log n)
- Ω(n): 버블 정렬 - 이미 정렬된 리스트인 경우
- Ω(log n)
- Ω(1): 선형 검색, 이진 검색

# 7) 재귀

### 재귀

- 함수가 본인 스스로를 호출해서 사용
- 마지막 상황에 아무것도 하지 않도록 하는 조건문을 추가해야 함

# 8) 병합 정렬

📐 O(nlogn)
- 숫자를 반으로 나누는 데 O(logn), 부분들을 정렬해서 병합하는 데 O(n)

- 원소가 한 개가 될 때까지 계속해서 반으로 나누다가 다시 합쳐나가며 정렬
- 재귀적으로 구현

# Quiz

1. 알고리즘의 성능 및 시간 복잡도를 표현하는 표기법 중 하나로, 최악의 경우일 때(상한)를 나타내는 것은?
    1. O()
2. name과 number 두 개의 멤버를 갖는 person이라는 새로운 자료형을 구조체를 정의하려고 합니다. 아래 코드의 괄호 안에 들어갈 코드로 알맞은 것은?
    1. typedef struct
3. 전화번호부 책에서 ‘이펭수’를 찾는 작업을 선형 검색으로 수행하게 될 경우 Big-O는 어떻게 될까요?
    1. O(n)
4. 5 6 7 3 2 → 오름차순 정렬을 위해 버블 정렬을 왼쪽부터 오른쪽까지 ‘한 번’ 수행했을 때의 리스트는?
    1. 5 6 3 2 7
5. 5 6 7 3 2 → 오름차순 정렬을 위해 선택 정렬 교환을 ‘한 번’ 수행했을 때의 리스트는?
    1. 2 6 7 3 5
6. 선택 정렬, 버블 정렬, 선형 검색, 이진 검색 4가지 알고리즘이 최선인 경우일 때의 실행시간이(하한) 빠른 순서대로 나열한 것은?
    1. 이진 검색 - 선형 검색 - 버블 정렬 - 선택 정렬
7. 아래 코드는 ‘#’으로 피라미드를 쌓는 코드입니다. 함수 안에서 함수 자기 자신을 호출하는 방식은?
    1. 재귀(recursive)
8. 아래 코드와 같이 피라미드 쌓기를 재귀적으로 작성한 코드에서 h값으로 3이 입력되었을 때 draw 함수는 총 몇 번 호출될까요? (최초 호출은 제외)
void draw(int h)
{
  if (h == 0)
  {
    return;
  }
  draw(h - 1);

  for (int i = 0; i < h; i++)
  {
    printf(”#”);
  }
  printf(”\n”);
}
    1. 3
9. 병합 정렬, 선택 정렬, 버블 정렬의 실행시간의 하한을 빠른 순서대로 정렬한 것은?
    1. 버블 정렬 - 병햡 정렬 - 선택 정렬
2. 알고리즘의 실행 시간의 상한을 비교하기 위해 Big-O 표기법을 사용합니다. 다음 Big-O 표기법 중 빠른 순서대로 올바르게 정렬한 것은?
    a. O(1) - O(log n) - O(n) - O(n^2)
