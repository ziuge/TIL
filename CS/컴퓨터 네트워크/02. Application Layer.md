# 02. Application Layer

# 2.1 Principles of Network Applications

주제 3가지

- application의 구조와 개념
- 인터넷에서 실제로 사용되고 있는 프로토콜
- 스스로 인터넷 애플리케이션 작성

보편적인 네트워크 앱

- 이메일, 웹, 게임, 유튜브, 스카이프

애플리케이션 구조

- client - server
- peer-to-peer

### Client-server architecture

- 서버
    - 언제나 켜져 있는 호스트
    - 영구적으로 할당된 IP 주소
    - 데이터 센터 형식으로 동작 (여러 서버 군집)
- 클라이언트
    - 서버와 커뮤니케이션
    - 인터넷에 연결되었다가 안되었다가 함
    - 변경 가능한 IP 주소
- 두 프로세스가 서로 통신

### P2P

- 언제나 켜진 호스트가 존재하지 않음
- 유저들(peer)끼리 커뮤니케이션
    - 대표적 장점: self scalability - 시스템의 규모가 커지더라도 괜찮음
- 관리가 매우 복잡함

### Processes communicating

- 프로세스: 호스트 안에서 실행 중인 프로그램
- 서로 다른 호스트에 있는 프로세스들간의 메시지 교환을 통한 통신
- client process: 커뮤니케이션을 초기화 → 클라이언트 호스트에서 실행
- server process: 응답하는 프로세스 → 서버 호스트에서 실행
- P2P의 경우, 둘 다 있을 수 있음.

### Sockets

- 프로세스는 소켓으로/으로부터 메시지를 보내고/받음
- 메시지를 내보내고 받을 때 사용하는 문 같은 존재
application - 앱 개발자가 컨트롤(나머지는 운영체제)
transport 계층으로 내보내거나 transport 계층에서 읽어올 때 사용됨
    
    
    | application |
    | --- |
    | transport |
    | network |
    | link |
    | physical |

### 프로세스 주소?

- 커뮤니케이션은 두 호스트의 프로세스간에 이루어짐
- 목적지는 어떻게 특정?
    - 호스트 IP 주소만 가지고는 궁극적인 목적지까지 식별X
    - **port numbers** 사용해야 함
- 포트 번호 예시: HTTP(Web) - 80, mail - 25 (well known port number)
- 호스트는 IP 주소로 식별, 호스트 안의 프로세스는 Port 번호로 식별

### What transport service does an app need? 앱이 필요한 transport 서비스는?

- data integrity
    - file 옮기기, 웹 상호작용 - data transfer 매우 중요함
    - 오디오, 비디오 - 로스 있어도 괜찮음
- timing
    - 인터넷 전화, 게임 등 딜레이 짧아야 함
- throughput
    - 멀티미디어 스티리밍 등 - 최소 throughput을 배달할 수 있어야 함
    - elastic 앱 - 괜찮음
- security
    - 보안 문제 중요한 앱
- 앱 별로 다름
    
    ![Screenshot 2023-09-27 at 3.29.03 PM.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9dfaa27e-2253-44c7-a1be-9622508402d5/b349890c-5120-4e33-941b-92f7d3cec7ee/Screenshot_2023-09-27_at_3.29.03_PM.png)
    

### 인터넷 프로토콜?

- TCP
    - reliable transport
        - 절대 오류 없이 순서대로 도착하는 것 확신
    - connection-oriented
        - 상대방과 (handshake하면서) 커넥션을 셋업하고나서 데이터 주고받음
        - 이걸 이용해서 flow control, congestion control도 이용
        - flow control - SendingTCP, ReceivingTCP - Application이 뽑아가는 속도보다 RTCP 버퍼에 더 많이 차게 되면 STCP에 신호를 보내서 버퍼가 넘치지 않게 함
        - congestion control - network의 부담을 줄여주는 control
    - 커넥션을 관리하기 위한 오버헤드가 발생할 수 있음. protocol control overhead → UDP를 사용하는 이유
        1. one-time transaction. 메시지 하나 보내고 값 하나 받으면 끝나는 상황일 경우, UDP가 훨씬 좋음
        2. data integrity가 극히 중요할 경우, transport 서비스만 믿기 보다는 application 자체 내에서 data integrity 확인을 해야함. 
        3. 멀티미디어 스트리밍의 경우, 단위 시간당 받아야 하는 최소 프레임이 존재. TCP의 경우 바로 내보내지 않고 홀드하고 있을 것. 
- UDP
    - unreliable transport
    - 제공하지 않음: timing, throughput guarantee, security …

![Screenshot 2023-10-04 at 3.18.01 PM.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9dfaa27e-2253-44c7-a1be-9622508402d5/dcba2af1-f176-4240-9d35-f8b8f15f100f/Screenshot_2023-10-04_at_3.18.01_PM.png)

- 데이터를 실어나르는 애플리케이션(email, web 등) → TCP에게 데이터 전달을 부탁
    - 중요한 것은 데이터 integrity이기 때문
- 스트리밍 멀티미디어 → 타이밍이 중요, minimum throughput 중요 → UDP 사용이 더 빈번함

- app protocol에서 정의되어야 하는 요소
    - 교환하는 메시지의 종류
    - 각 메시지의 syntax
    - message semantics(어떻게 해석되어야 하는지)
    - 규칙 rules
- open vs proprietary
    - proprietary: 실제로 어떻게 동작하는지 알 수 없음. 짐작할 뿐
    - open: (ex. HTTP, SMTP) 인터넷 표준을 담고 있는 RFC document에 다 오픈되어있음.
        - interoperability(정보처리 상호운용))가 좋음. 규약에 따라 메시지를 주고받으면 되므로.

# 2.2 Web and HTTP

### Web을 위해 만들어진 프로토콜, HTTP

- 웹 페이지는 여러 개의 객체로 구성되어 있음.
- 기본적으로 웹 페이지의 프레임을 베이스 html-file이 설명하고 있음. 그리고 그 안에 각 객체에 대한 참조(URL 형태)를 포함하고 있음. (www.someschool.edu/someDept/pic.gif)
- object - JPEG, HTML, audio file… 등

### HTTP Overview

- hypertext transfer protocol
- email에서 사용하는 경우도. 다른 애플리케이션에서도 사용됨. 원래는 web이라는 애플리케이션을 위해 디자인됨
- client-server 구조를 따름.
    - client: 웹 객체를 요청, 받음, 보여주는 브라우저
    - server: 브라우저의 요청을 기다려서 해당 객체를 전송하는 웹 서버
- PC running Firefox browser - iPhone running Safari browser
    - Firefox, Safari는 서로 다른 브라우저(프로그램)지만, HTTP가 정의하는 방식을 따라서 request 메시지를 만들고 response를 받음.
- Application Program, Application Protocol의 차이와 관계를 확실히 알 수 있음.

- HTTP라는 App Protocol은 Transport service를 TCP에 요청
    - HTTP가 지원하는 웹은 data integrity가 중요하므로 TCP에 요청
    - 브라우저에 URL을 입력하면 그에 해당하는 웹 페이지를 받아오기 위해 HTTP request 메시지를 만듦. 전달하기 전엔 TCP 커넥션을 맺어야 함. client에서 TCP 커넥션을 initiate, port 80
    - server가 TCP connection을 받아들임
    - 그 커넥션을 통해 메시지를 주고받게 됨
    - 그다음엔 TCP connection 이 닫힘
- HTTP is stateless
    - 유저가 이전에 보낸 요청이 뭐였는지 전혀 기억을 하지 않음.
    - 프로토콜이 stateful하려면 매우 복잡해짐. 어딘가에 저장하고 있어야 함. 크래시가 발생하면 또 상당한 오버헤드가 들어감.
    - 많은 프로토콜들이 stateless임

HTTP connections

- non-persistent HTTP
    - 서버 측에서 객체 하나 보내주고 나면 TCP connection을 자동으로 닫음
    - 웹 페이지에 object가 10개라면 10번 커넥션을 맺어야함 → 매우 비효율적
- persistent HTTP
    - 일단 한번 client-server 사이에 커넥션을 맺고 여러 object를 전달할 수 있도록 함

### Non-persistent HTTP

1. HTTP cilent initiates TCP connection
    1. HTTP server at host “accept”
2. HTTP client sends request message
3. requested object를 담은 response message → socket
4. HTTP server closes TCP connection
5. HTTP client receives response message - parsing html file. 추가적인 object에 대한 참조를 찾아냄. 각각을 또 요청
6. 1~5 단계를 10번(object의 개수만큼) 계속 함
